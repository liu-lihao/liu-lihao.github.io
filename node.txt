**********************完整的一次HTTP请求*********************
内容来自，但简化了：
https://blog.csdn.net/skyxmstar/article/details/68059927
https://www.linux178.com/web/httprequest.html
文中*[num]号表示下方有介绍，详细内容请看链接。

1. 解析域名获取IP*[1]
    在浏览器中输入网址，发送至DNS服务器并获得域名对应的WEB服务器的IP地址；

2. 发起TCP的3次握手，建立TCP连接*[2]
    在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

3. Web浏览器向Web服务器发送HTTP请求信息
    1)请求方法（GET/POST）、URI、协议/版本
    2)请求头(Request Header)
    3)空行
    4)请求正文(POST方式的From Data)

4. Web服务器应答，发送HTTP响应信息
    1)状态行
    2)响应头(Response Header)
    3)响应正文（数据/资源）*[3]

5. Web服务器关闭TCP连接 
    一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接（受限于老旧的HTTP 1.0）。
    然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。


[1]解析域名获取IP：域名解析（DNS解析）
    首先Chrome浏览器会解析 www.linux178.com 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？
    ① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.linux178.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。
        注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看
    ② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.
        注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看
    ③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。
    ④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com  对应的IP地址，该进行一步的动作了。

[2]发起TCP的3次握手：
    客户端：天王盖地虎
    服务器端：老虎不在家
    客户端：天王请开门 （再次确认。）
    服务器端收到（再次确认。），这个TCP连接就进入Established状态，就可以发起http请求了。详见链接。

[3]响应正文：
    若正常打开网站，浏览器会拿到index.html文件，开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。
    浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。
    
————————————————————————————————————————————
    
**********************重排和重绘*********************
重绘(repaint或redraw)：
    仅外观改变，其盒子位置大小等不变的情况下，对元素的新属性进行重绘。
    注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。
重排(重构/回流/reflow)：
    元素的规模尺寸，布局，隐藏等改变而需要重新构建的行为。页面第一次加载必会有一次重排，再重绘。
    注意：每次重排(或重构/回流/reflow)后必回再进行重绘。
    触发重排的条件：任何页面布局和几何属性的改变都会触发重排。
        如：1、页面渲染初始化；(无法避免)
        　　2、添加或删除可见的DOM元素；
        　　3、元素位置的改变，或者使用动画；
        　　4、元素尺寸的改变——大小，外边距，边框；
        　　5、浏览器窗口尺寸的变化（resize事件发生时）；
        　　6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；
        　　7、读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE)　)

浏览器运行机制：
    1、构建DOM树（parse）：【分析所有节点 .html+.js】
        渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）；
    2、构建渲染树（construct）：【获取所有css .html+.css+.js】
        解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如<b></b>），构建渲染树（Rendering Tree/Frame Tree）；
    3、布局渲染树（reflow/layout）：【计算每个元素】
        从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；
    4、绘制渲染树（paint/repaint）：【渲染】
        遍历渲染树，使用UI后端层来绘制每个节点。

减少重绘和重排的优化方案：*减少并合并DOM操作和Style样式请求。
    1、直接一次性改className。
    2、先display：none;再各种修改后，再display:block;。
    3、使用cloneNode(true or false)和replaceChild。
    4、使用postion属性设置为absolute或fixed，使元素脱离文档流。
    5、使用DocumentFragment(节点碎片)打包要添加的节点后一次性加入到document。
    6、尽量不要使用table布局。
